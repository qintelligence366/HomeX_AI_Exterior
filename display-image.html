<!DOCTYPE html>
<html>
<head>
    <script src="https://hammerjs.github.io/dist/hammer.min.js"></script> <!-- 引入 Hammer.js 库 / Include Hammer.js library -->
</head>
<body>
    <canvas id="canvas" style="border: 1px solid black;"></canvas> <!-- 设置边框以可视化 Canvas 区域 / Set border to visualize Canvas area -->
    <div id="buttons" style="display: none;">
        <button id="confirmButton">确定 / Confirm</button>
        <button id="resetButton">重选 / Reset</button>
    </div>
    <script>
        const canvas = document.getElementById("canvas"); // 获取 Canvas 元素 / Get Canvas element
        const ctx = canvas.getContext("2d"); // 获取 2D 绘图上下文 / Get 2D drawing context
        let image = new Image(); // 创建图片对象 / Create image object
        let points = []; // 存储点击点坐标的数组 / Array to store click point coordinates
        let isClosed = false; // 标记多边形是否闭合 / Flag to indicate if polygon is closed
        let scale = 1; // 缩放比例 / Zoom scale
        let originX = 0; // 原始 x 偏移 / Original x offset
        let originY = 0; // 原始 y 偏移 / Original y offset
        let baseWidth, baseHeight; // 基础尺寸 / Base dimensions
        let regions = []; // 存储多个框选区域 / Array to store multiple selected regions
        const confirmButton = document.getElementById("confirmButton"); // 确定按钮 / Confirm button
        const resetButton = document.getElementById("resetButton"); // 重选按钮 / Reset button
        const buttonsDiv = document.getElementById("buttons"); // 按钮容器 / Buttons container

        // 动态接收 URL 参数 / Dynamically receive URL parameters
        const params = new URLSearchParams(window.location.search);
        let imageUrl = params.get("imageUrl") || "https://via.placeholder.com/300";
        if (imageUrl && !imageUrl.includes("via.placeholder")) {
            if (!imageUrl.includes("auto=format")) {
                imageUrl += "?auto=format&q=20"; // 如果缺少参数，添加 imgix 优化参数 / Add imgix optimization parameters if missing
            }
        }
        image.src = imageUrl;

        image.onload = () => {
            const maxWidth = 345; // 设置最大宽度为 345px，与 Adalo 图片组件一致 / Set max width to 345px, matching Adalo image component
            const maxHeight = 250; // 设置最大高度为 250px，与 Adalo 图片组件一致 / Set max height to 250px, matching Adalo image component
            const scaleRatio = Math.min(maxWidth / image.width, maxHeight / image.height); // 计算缩放比例以保持纵横比 / Calculate scale to maintain aspect ratio
            baseWidth = image.width * scaleRatio; // 计算基础宽度 / Calculate base width
            baseHeight = image.height * scaleRatio; // 计算基础高度 / Calculate base height

            canvas.width = baseWidth; // 设置 Canvas 宽度 / Set Canvas width
            canvas.height = baseHeight; // 设置 Canvas 高度 / Set Canvas height
            draw(); // 初始化绘制 / Initial draw

            console.log("Canvas initialized:", canvas.width, canvas.height); // 调试：打印 Canvas 初始化信息 / Debug: Log Canvas initialization info
        };

        // 计算两点之间的距离 / Calculate distance between two points
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        // 绘制图片和多边形 / Draw image and polygon
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除画布 / Clear canvas
            ctx.save(); // 保存当前状态 / Save current state
            ctx.scale(scale, scale); // 应用缩放 / Apply zoom
            ctx.translate(originX, originY); // 应用偏移 / Apply offset
            ctx.drawImage(image, 0, 0, baseWidth / scale, baseHeight / scale); // 绘制图片 / Draw image

            // 绘制红点 / Draw red points
            const pixelRatio = window.devicePixelRatio || 1; // 获取设备像素比 / Get device pixel ratio
            const dotRadius = 2 * pixelRatio; // 调整红点大小为 2 像素，乘以像素比 / Adjust dot radius to 2 pixels, multiplied by pixel ratio
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x / scale - originX, point.y / scale - originY, dotRadius, 0, 2 * Math.PI); // 红点半径 / Red dot radius
                ctx.fillStyle = "red";
                ctx.fill();
            });

            // 绘制所有已确认的框选区域 / Draw all confirmed regions
            regions.forEach(region => {
                ctx.beginPath();
                ctx.moveTo((region[0].x - originX) / scale, (region[0].y - originY) / scale);
                for (let i = 1; i < region.length; i++) {
                    ctx.lineTo((region[i].x - originX) / scale, (region[i].y - originY) / scale);
                }
                ctx.closePath();
                ctx.strokeStyle = "lightblue"; // 框选线颜色 / Polygon outline color
                ctx.stroke();
            });

            // 绘制当前正在框选的多边形 / Draw the current polygon being selected
            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo((points[0].x - originX) / scale, (points[0].y - originY) / scale); // 从第一个点开始 / Start from the first point
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo((points[i].x - originX) / scale, (points[i].y - originY) / scale); // 连接到下一个点 / Connect to the next point
                }
                // 如果多边形已闭合，保持闭合状态 / If polygon is closed, maintain closed state
                if (isClosed) {
                    ctx.closePath();
                    ctx.strokeStyle = "lightblue";
                    ctx.stroke();
                } else if (points.length >= 4) {
                    const firstPoint = points[0];
                    const lastPoint = points[points.length - 1];
                    const distanceThreshold = 20; // 距离阈值，单位像素，可调整 / Distance threshold in pixels, adjustable
                    if (getDistance(firstPoint, lastPoint) < distanceThreshold) {
                        ctx.closePath();
                        ctx.strokeStyle = "lightblue";
                        ctx.stroke();
                        isClosed = true; // 标记多边形已闭合 / Mark polygon as closed
                        buttonsDiv.style.display = "block"; // 显示按钮 / Show buttons
                    }
                }
            }
            ctx.restore(); // 恢复状态 / Restore state
        }

        // 处理点击事件（PC 和移动设备） / Handle click events (PC and mobile devices)
        function handleInteraction(e) {
            if (isClosed) return; // 如果已闭合，停止添加新点 / If closed, stop adding new points

            e.preventDefault(); // 防止默认触摸行为 / Prevent default touch behavior
            const rect = canvas.getBoundingClientRect(); // 获取 Canvas 的边界矩形 / Get Canvas bounding rectangle
            const x = (e.type.includes("touch") ? e.touches[0].clientX : e.clientX) - rect.left; // 计算 x 坐标 / Calculate x coordinate
            const y = (e.type.includes("touch") ? e.touches[0].clientY : e.clientY) - rect.top; // 计算 y 坐标 / Calculate y coordinate

            // 存储点击点 / Store click point
            points.push({ x: x, y: y });

            // 重新绘制 / Redraw
            draw();

            // 调试：打印点击位置到控制台 / Debug: Log click position to console
            console.log("Clicked at:", x, y);
        }

        // 支持点击和触摸事件 / Support click and touch events
        canvas.addEventListener("click", handleInteraction);
        canvas.addEventListener("touchstart", handleInteraction);

        // 确定按钮点击事件 / Confirm button click event
        confirmButton.addEventListener("click", () => {
            if (isClosed) {
                regions.push([...points]); // 保存当前框选区域 / Save current region
                points = []; // 清空当前点，准备下一次框选 / Clear current points for next selection
                isClosed = false; // 重置闭合状态 / Reset closed state
                buttonsDiv.style.display = "none"; // 隐藏按钮 / Hide buttons
                draw(); // 重新绘制 / Redraw
                console.log("Regions confirmed:", regions); // 调试：打印所有框选区域 / Debug: Log all regions
            }
        });

        // 重选按钮点击事件 / Reset button click event
        resetButton.addEventListener("click", () => {
            points = []; // 清空当前点 / Clear current points
            isClosed = false; // 重置闭合状态 / Reset closed state
            buttonsDiv.style.display = "none"; // 隐藏按钮 / Hide buttons
            draw(); // 重新绘制 / Redraw
        });

        // 初始化 Hammer.js 实现缩放 / Initialize Hammer.js for pinch-to-zoom
        const hammer = new Hammer(canvas);
        hammer.get('pinch').set({ enable: true }); // 启用双指缩放 / Enable pinch-to-zoom
        let lastScale = 1; // 上次缩放比例 / Last scale value
        hammer.on("pinch", (e) => {
            scale = lastScale * e.scale; // 计算当前缩放比例 / Calculate current scale
            scale = Math.min(Math.max(1, scale), 3); // 限制缩放范围 1x 到 3x / Limit zoom range from 1x to 3x
            draw(); // 重新绘制 / Redraw
        });
        hammer.on("pinchend", (e) => {
            lastScale = scale; // 更新最后缩放比例 / Update last scale value
        });

        // 调试：打印 URL 到控制台 / Debug: Log URL to console
        console.log("Image URL:", imageUrl);
    </script>
</body>
</html>
